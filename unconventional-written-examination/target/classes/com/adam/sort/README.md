# 快速排序实现要点

## 核心思想

分治法：选基准 → 分区（小于基准放左边，大于等于放右边）→ 递归处理左右两部分

## 关键实现：双指针分区

### 为什么必须先移动右指针？

**核心原理：**
- 基准在左边（`arr[left]`），最后要交换到 `i` 和 `j` 相遇的位置
- 相遇点的元素必须 ≤ 基准，才能安全交换
- 先移动右指针，保证相遇点满足条件

**错误示例（先移动左指针）：**
```
数组：[5, 6, 7, 8, 1]，基准 = 5

1. 先移动左指针 i：找到 arr[1] = 6 > 5，i 停在 1
2. 移动右指针 j：找到 arr[4] = 1 < 5，j 停在 4
3. 交换：[5, 1, 7, 8, 6]
4. 继续：i 找到 7，j 找不到，相遇在位置 2
5. arr[2] = 7 > 5 ❌ 不能交换！
```

**正确做法（先移动右指针）：**
```
数组：[5, 1, 2, 3, 4]，基准 = 5

1. 先移动右指针 j：找到 arr[3] = 3 < 5，j 停在 3
2. 移动左指针 i：找不到 > 5 的元素，i 移动到 j 的位置
3. 相遇在位置 3，arr[3] = 3 < 5 ✅ 可以交换
4. 交换后：[3, 1, 2, 5, 4]，基准 5 在正确位置
```

**记忆规则：**
- 基准在左边 → 先移动右指针
- 基准在右边 → 先移动左指针
- 原则：从基准的"对面"开始移动

## 代码实现

```java
private static int partition(int[] arr, int left, int right) {
    int pivot = arr[left];
    int i = left, j = right;
    
    while (i < j) {
        // 关键：先移动右指针
        while (i < j && arr[j] >= pivot) j--;
        while (i < j && arr[i] <= pivot) i++;
        if (i < j) swap(arr, i, j);
    }
    
    swap(arr, left, i);  // 将基准放到最终位置
    return i;
}
```

## 时间复杂度

- 平均：O(n log n)
- 最坏：O(n²) - 每次选到最值（已排序数组）
- 优化：随机化选择基准，避免最坏情况

